;; Copyright (C) 2021 SURFnet B.V.
;;
;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
;; more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with this program. If not, see http://www.gnu.org/licenses/.

(ns ooapi-gateway-configurator.model
  "This is the internal data model for the configurator app.

  The model is implemented in datascript. We expose the datascript
  interface to the UI and handlers.

  The assumption is that the datascript query / transaction model is
  convienient enough that we don't need a lot of translation code. See
  also the [[event->tx]] multi-method.

  We still need some glue code to translate between the datascript
  model and the eventual gateway configuration file (a yml file, tree
  structure). This yaml tree is what's stored on disk (via the store
  and versionining namespaces).

  See the [[schema]] for more details."
  (:require [clojure.set :as set]
            [datascript.core :as d]))


(def schema
  "Datascript schema for the configurator.

    This schema defines the attributes in the model that have special
    properties. In contrast with Datomic, you do not need to specify all
    attributes you're going to use, and you do not need to specify the
    value type for any attribute except when the attribute is a ref.

    Attributes that aren't in the schema can still be added to the db
    with any value.

    ## Attribute and entities in Datascript

    Note the datascript, like datomic, is an attribute entity value (AEV)
    store. Fundamentally you're always dealing with individual AEV
    entries.  Entities can be \"typed\" by having a particular attribute,
    but there is no restriction on which attributes an entity may contain.

    You can query for entity maps, including relationships by using Pull
    syntax. This will return one or more possibly nested maps of
    attribute-value pairs, so you don't have to deal with seqs of
    attributes directly.

    See also https://docs.datomic.com/on-prem/query/query.html

    You add/remove attributes in a transaction one by one, or you can
    add a collection of attributes as a map:

    ```
    (def transaction
       [;; add :some/attribute
        [:db/add some-id :some/attribute \"value\"]

        ;; remove :some/other with any value
        [:db/retract some-id :some/other]

        ;; remove :some/other with particular value
        [:db/retract some-id :some/other \"value\"]

        ;; entity map transaction:
        ;; adds a whole bunch of attributes
        {:db/id some-id
         :some/attribute \"value\"
         :some/other \"new value\"}

        ;; remove an entity completely; removes all attributes
        [:db/retractEntity that-id]])
    ```

    Note that you cannot _remove_ attributes by using the entity map
    transactions!

    See also https://docs.datomic.com/on-prem/transactions/transactions.html

    ## Entities in the schema

    The schema defines 4 entity types:

      - Institutions: entities that have an `:institution/id`.
      - Apps: entities that have an `:app/id`.
      - Access: entities that represent the paths on an institution that
        an app can access. Access entities can be identified by an
        `:access/app+institution` attribute (a tuple of `:db/id`s)
      - Paths: entities that have a `:path/spec` identity attribute. There
        is a path entity for each path defined in the gateway
        configuration apiEndpoints entry.


    ## Identities

    The `:app/id`, `:institution/id`, `:path/spec` and
    `:access/app+institution` attributes are _identities_. You can use
    tuples like `[:app/id \"my.app.id\"]` in places where you'd otherwise
    have to use the autogenerated `:db/id` value.

    In datascript/datomic, relationships between entities are defined as
    one-way `:db/valueType :db.type/ref`, attributes that refer to another
    entity id `:db/id`.

    ## Relationships and querying

    You can traverse the refs in either direction when querying for
    data, and refs may be defined as `:db/cardinality
    :db.cardinality/many`, meaning that an entity may have more than one
    value for the same ref attribute. This means there are many
    possiblities when modeling relationships.

    In our case we define the relationships as follows:

    ```
       Access
       :access/institution --------> Institution
       :access/app         --------> App
       :access/paths       -(many)-> Path
    ```

    This main reason for this setup is to enforce a uniqueness constraint;
    the `:access/app+institution` attribute is unique and auto-generated
    from the `:access/institution` and `:access/app` attributes. This
    prevents duplicate entries for the same acces + institution pair.

    Doing the model this way also means that when no paths are allowed for
    a particular app+institution pair, this can be modeled in two ways; we
    can either have an access entity with the `:access/app+institution`
    attribute but no `:access/paths` attributes for that entity, or the
    entity does not exist at all.

    See the [[set-paths]] function in this namespace that can update paths
    correctly in either case."

  {;; Institutions and apps have unique ids, and are addressable by id
   ;; in the datascript model.
   ;;
   ;; This means that instead of having to refer to the entities by
   ;; their auto-generated :db/id attribute in queries and
   ;; transactions, you can use "refs", like `[:app/id "my.app.name"]`
   ;;
   ;; See also :access/app and :access/institution, below.
   :institution/id {:db/unique :db.unique/identity
                    :db/doc    "The unique id (name) of the institution. Can be used as a ref"}
   :app/id         {:db/unique :db.unique/identity
                    :db/doc    "The unique id (name) of the institution. Can be used as a ref"}

   ;; We list all attributes here even when they have no definition
   ;; datascript does not require this, but we can use it to filter
   ;; out unexpected attributes.
   :app/notes                 {}
   :app/password-hash         {}
   :app/password-salt         {}
   :institution/notes         {}
   :institution/proxy-options {}
   :institution/url           {}

   :path/spec {:db/unique :db.unique/identity
               :db/doc    "A single path that can be accessed."}

   ;; An access entity has a collection of paths, each referring to a
   ;; :path/spec - so you can't add an :access/path that refers to a
   ;; non-existing :path/spec
   :access/paths {:db/cardinality :db.cardinality/many
                  :db/valueType   :db.type/ref
                  :db/doc         "Collection of paths that may be accessed for this app+institution pair."}

   ;; We want to assert that there is only a single access entity per
   ;; app + institution combination. To do that, have we have the refs
   ;; on the access entity referring to the app and institution, and
   ;; then create a composite tuple on that access entity that will be
   ;; unique.
   ;;
   ;; see also https://docs.datomic.com/on-prem/schema/schema.html#composite-tuples
   :access/app             {:db/valueType :db.type/ref}
   :access/institution     {:db/valueType :db.type/ref}
   :access/app+institution {:db/tupleAttrs [:access/app :access/institution]
                            :db/unique     :db.unique/identity}})

(def belongs-to-attrs
  "Attributes referring to entities that \"own\" this entity.
  This is used by [[retract-recursive]] to automatically remove owned
  entities with their owner."
  #{:access/app :access/institution})

(defn- directly-owned-eids
  "Find all entities directly owned by this one, as indicated through
  `belongs-to-attrs`."
  [db eid]
  (into #{}
        (comp (mapcat #(d/datoms db :avet % eid))
              (map first))
        belongs-to-attrs))

(defn- owned-eids
  [db eid seen]
  (let [owned     (directly-owned-eids db eid)
        new-owned (set/difference owned seen) ;; ignore entities already seen
        seen      (into seen owned)]
    (into seen (mapcat #(owned-eids db % seen)) new-owned)))

(defn retract-recursive
  "Recursively retract an entity given by `ref`.

  Return a transaction (coll of retractions) that will remove the
  given entity and any entities belonging to it as given by
  `belongs-to-attrs` - a set of attributes."
  [db ref]
  (when-let [eid (d/entid db ref)]
    (into [[:db/retractEntity eid]]
          (map (fn [e] [:db/retractEntity e]))
          (owned-eids db eid #{}))))

(defn api-paths
  [model]
  ;; `[?p ...]` means return a coll of scalars (not a set of tuples)
  (set (d/q '[:find [?p ...] :where [_ :path/spec ?p]] model)))

(defn app-ids
  [model]
  (set (d/q '[:find [?id ...] :where [_ :app/id ?id]] model)))

(defn app-by-id
  [model id]
  (d/pull model '[*] [:app/id id]))

(defn apps
  [model]
  (->> (d/q '[:find [(pull ?e [*]) ...] :where [?e :app/id _]] model)
       set))

(defn institution-ids
  [model]
  (set (d/q '[:find [?id ...] :where [_ :institution/id ?id]] model)))

(defn institution-by-id
  [model id]
  (d/pull model '[*] [:institution/id id]))

(defn institutions
  [model]
  (->> (d/q '[:find [(pull ?e [*]) ...] :where [?e :institution/id _]] model)
       set))

(defn remove-app
  [model app-id]
  (retract-recursive model [:app/id app-id]))

(defn remove-institution
  [model institution-id]
  (retract-recursive model [:institution/id institution-id]))

(defn- access-eid
  [model app-id institution-id]
  (d/q '[:find ?xs . :where
         :in $ ?app-id ?institution-id
         :where
         [?a :app/id ?app-id]
         [?i :institution/id ?institution-id]
         [?xs :access/app ?a]
         [?xs :access/institution ?i]]
       model app-id institution-id))

(defn set-paths
  "Set the paths on institution that app may access.

  Returns a Datascript transaction. `app-id` and `institution-id` are
  required, paths is a collection of path strings.

  This will remove any paths in `model` that are not specified in
  `paths`, and works whether the relevant `access` entity already
  exists, or not. See also [[schema]]"
  [model {:keys [app-id institution-id paths]}]
  {:pre [(string? app-id) (string? institution-id) (or (nil? paths) (coll? paths))]}
  (if-let [xs (access-eid model app-id institution-id)]
    ;; if there already is an access entity, retract all its paths and
    ;; add the given ones
    (into [[:db/retract xs :access/paths]]
          (map (fn [spec]
                 [:db/add xs :access/paths [:path/spec spec]])
               paths))
    ;; if there isn't an access entity yet, create a new one
    [{:access/institution [:institution/id institution-id]
      :access/app         [:app/id app-id]
      :access/paths       (map (fn [path] [:path/spec path]) paths)}]))

(defn get-paths
  "Query the paths on institution that app may access.

  Returns a set of path strings, or `nil` if no there are no paths for
  the given app + institution combination."
  [model {:keys [app-id institution-id]}]
  {:pre [(string? app-id) (string? institution-id)]}
  (when-let [specs (d/q '[:find [?paths ...]
                          :in $ ?app-id ?institution-id
                          :where
                          [?p :path/spec ?paths]
                          [?a :app/id ?app-id]
                          [?xs :access/paths ?p]
                          [?xs :access/app ?a]
                          [?xs :access/institution ?i]
                          [?i :institution/id ?institution-id]]
                        model app-id institution-id)]
    (set specs)))

;; Events

(defmulti event->tx
  "Given a datascript `model` and an `event` map, returns a datascript
  transaction that projects the event on the model

  Note that a transaction is a collection of changes.  See also
  https://docs.datomic.com/on-prem/transactions/transactions.html"
  (fn [_ event]
    (:event/type event)))

(defmethod event->tx :set-paths
  [model event]
  (set-paths model event))

(defmethod event->tx :upsert-app
  [_ {:keys [orig-id] :as event}]
  (cond-> []
    (and orig-id (not= orig-id (:app/id event)))
    ;; The app/id changed. We need to transact that attribute
    ;; first. This transaction finds the attribute by its original
    ;; id, and sets its value to the new id.
    (conj [:db/add [:app/id orig-id] :app/id (:app/id event)])

    true
    ;; Update the rest of the attributes; uses an entity map as a
    ;; change. This adds all attributes in the map that are defined in
    ;; the db schema. The entity is found by the app/id attribute.
    ;;
    ;; See also
    ;; https://docs.datomic.com/on-prem/transactions/transactions.html#adding-entity-references
    (conj (select-keys event (keys schema)))))

(defmethod event->tx :remove-app
  [model {:app/keys [id]}]
  (remove-app model id))

(defmethod event->tx :upsert-institution
  [_ {:keys [orig-id] :as event}]
  (cond-> []
    (and orig-id (not= orig-id (:institution/id event))) ;; alter institution id
    (conj [:db/add [:institution/id orig-id] :institution/id (:institution/id event)])

    true
    (conj (select-keys event (keys schema)))))

(defmethod event->tx :remove-institution
  [model {:institution/keys [id]}]
  (remove-institution model id))
